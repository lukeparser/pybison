#!/usr/bin/env python
"""
Template of a pyBison parser file

This is actually a working parser, but so
minimal as to be totally useless. Refer to the
'.on_someTarget()' rule handler in the class
'Parser' below for more info.

You can do much worse than to copy this file
somewhere, and tinker away to your heart's content.
"""
from bison import BisonParser, BisonNode

# -------------------------------------------
# Our own custom base class for all objects
# which get inserted into the parse tree
# -------------------------------------------

class ParseNode(BisonNode):
    """
    This is the base class from which all your
    parse nodes are derived.
    Add methods to this class as you need them
    """
    def __init__(self, **kw):
        BisonNode.__init__(self, **kw)

    def __str__(self):
        """Customise as needed"""
        return "<%s instance at 0x%x>" % (self.__class__.__name__, hash(self))

    def __repr__(self):
        """Customise as needed"""
        return str(self)

    def dump(self, indent=0):
        """
        Dump out human-readable, indented parse tree
        Customise as needed - here, or in the node-specific subclasses
        """
        BisonNode.dump(self, indent) # alter as needed

# ----------------------------------------------------
# Now, we need to define a node class for each parse
# target. (This is completely optional, but it can
# turn out to be a PITA if you don't).
# ----------------------------------------------------

class someTarget_Node(ParseNode):
    """
    Holds a "someTarget" parse target and its components.
    """
    def __init__(self, **kw):
        ParseNode.__init__(self, **kw)

    def dump(self, indent=0):
        ParseNode.dump(self, indent)


# ----------------------------------------------------
# Now, at last, we get to the main Parser class itself
# ----------------------------------------------------

class Parser(BisonParser):
    """
    Describe your parser here
    """

    # bison options
    options = ["%define api.value.type {void *}"]

    # basename of binary parser engine dynamic lib
    bisonEngineLibName = "template-engine"

    # ----------------------------------------------------------------
    # lexer tokens - these must match those in your lex script (below)
    # ----------------------------------------------------------------
    tokens = [ 'WORD' ]

    # ------------------------------
    # precedences
    # ------------------------------
    precedences = (
        #('left', ('aTarget1', 'aTarget2',..., 'aTargetn')),
        #('right', ('another_target1', 'another_target2',..., 'another_targetn')),
        )

    # ---------------------------------------------------------------
    # These methods are the python handlers for the bison targets.
    # (which get called by the bison code each time the corresponding
    # parse target is unambiguously reached)
    #
    # WARNING - don't touch the method docstrings unless you know what
    # you are doing - they are in bison rule syntax, and are passed
    # verbatim to bison to build the parser engine library.
    # ---------------------------------------------------------------

    # Declare the start target here (by name)
    start = "someTarget"

    def on_someTarget(self, target, option, names, values):
        """
        someTarget
        :
        | someTarget WORD
        """
        print("on_someTarget: %s %s" % (option, repr(values)))
        node = someTarget_Node(target=target,
                               option=option,
                               names=names,
                               values=values)
        return node

    # -----------------------------------------
    # raw lex script, verbatim here
    #
    # the script used here in this template is one which
    # breaks up the input stream into strings of
    # alphanumeric 'words' and discards everything else
    # -----------------------------------------
    lexscript = r"""
%{
#include <stdio.h>
#include <string.h>
#include "Python.h"
#include "tmp.tab.h"
//int yylineno = 0;
int yywrap() { return(1); }
extern void *py_parser;
extern void (*py_input)(PyObject *parser, char *buf, int *result, int max_size);
#define returntoken(tok) yylval = PyUnicode_FromString(strdup(yytext)); return (tok);
#define YY_INPUT(buf,result,max_size) { (*py_input)(py_parser, buf, &result, max_size); }
%}

%%

[a-zA-Z0-9\.]+ { returntoken(WORD); }
[ \t\n]        { /* ignore spaces/tabs/newlines */ }
.              { printf("unknown char %c ignored\n", yytext[0]); /* ignore bad chars */}

%%
//yywrap() { return(1); }

    """
    # -----------------------------------------
    # end raw lex script
    # -----------------------------------------

# --------------------------------------------------
# global functions to add in unit-testing our parser
# (same as what gets generated by bison2py)
# --------------------------------------------------


def main():
    """
    Unit-testing func
    """
    import argparse
    parser = argparse.ArgumentParser(prog="PyBison Parser Template")
    parser.add_argument("-k", "--keepfiles", action="store_true",
                        help="Keep temporary files used in building parse engine lib")
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="Enable verbose messages while parser is running")
    parser.add_argument("-d", "--debug", action="store_true",
                        help="Enable garrulous debug messages from parser engine")
    parser.add_argument("filename", type=str, nargs="*",
                        help="path of a file to parse, defaults to stdin")
    args = parser.parse_args()

    if isinstance(args.filename, list) and len(args.filename) == 0:
        args.filename = None

    p = Parser(verbose=args.verbose, keepfiles=args.keepfiles)

    forrest = []
    if args.filename is None:
        print("(Reading from standard input - please type stuff)")
        tree = p.run(file=None, debug=args.debug)
        forrest.append(tree)
    else:
        for fp in args.filename:
            tree = p.run(file=fp, debug=args.debug)
            forrest.append(tree)
    return forrest


if __name__ == "__main__":
    main()

